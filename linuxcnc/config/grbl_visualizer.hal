# grblHAL Visualizer - HAL Configuration
# Version con Vismach 3D

loadrt [KINS]KINEMATICS
loadrt [EMCMOT]EMCMOT base_period_nsec=[EMCMOT]BASE_PERIOD servo_period_nsec=[EMCMOT]SERVO_PERIOD num_joints=[KINS]JOINTS

# Componente de recepcion TCP
loadusr -Wn grbl_remote python3 grbl_hal_bridge.py --ip 192.168.1.76

# Visualizador Vismach 5 ejes
loadusr -Wn grbl_visualizer python3 vismach_5axis.py

addf motion-command-handler servo-thread
addf motion-controller servo-thread

# Conexiones:
# 1. TCP -> Feedback LinuxCNC (para el DRO)
net remote-x-pos grbl_remote.axis.x.pos => joint.0.motor-pos-fb
net remote-y-pos grbl_remote.axis.y.pos => joint.1.motor-pos-fb
net remote-z-pos grbl_remote.axis.z.pos => joint.2.motor-pos-fb
net remote-a-pos grbl_remote.axis.a.pos => joint.3.motor-pos-fb
net remote-c-pos grbl_remote.axis.c.pos => joint.4.motor-pos-fb

# 2. TCP -> Modelo 3D Vismach (para ver la maquina moverse)
# Conectamos DIRECTO desde grbl_remote al visualizador, saltandonos el motion controller
# para evitar problemas si LinuxCNC no esta en estado Machine On.
net remote-x-pos => grbl_visualizer.axis_x
net remote-y-pos => grbl_visualizer.axis_y
net remote-z-pos => grbl_visualizer.axis_z
net remote-a-pos => grbl_visualizer.axis_a
net remote-c-pos => grbl_visualizer.axis_c

# Machine enable loops
net estop-loop iocontrol.0.user-enable-out iocontrol.0.emc-enable-in
net tool-prep-loop iocontrol.0.tool-prepare iocontrol.0.tool-prepared
net tool-change-loop iocontrol.0.tool-change iocontrol.0.tool-changed
